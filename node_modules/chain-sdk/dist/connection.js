'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// FIXME: Microsoft Edge has issues returning errors for responses
// with a 401 status. We should add browser detection to only
// use the ponyfill for unsupported browsers.
var _require = require('fetch-ponyfill')(),
    fetch = _require.fetch;

var errors = require('./errors');
var btoa = require('btoa');

var blacklistAttributes = ['after', 'asset_tags', 'asset_definition', 'account_tags', 'next', 'reference_data', 'tags'];

var snakeize = function snakeize(object) {
  for (var key in object) {
    var value = object[key];
    var newKey = key;

    // Skip all-caps keys
    if (/^[A-Z]+$/.test(key)) {
      continue;
    }

    if (/[A-Z]/.test(key)) {
      newKey = key.replace(/([A-Z])/g, function (v) {
        return '_' + v.toLowerCase();
      });
      delete object[key];
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && !blacklistAttributes.includes(newKey)) {
      value = snakeize(value);
    }

    object[newKey] = value;
  }

  return object;
};

var camelize = function camelize(object) {
  for (var key in object) {
    var value = object[key];
    var newKey = key;

    if (/_/.test(key)) {
      newKey = key.replace(/([_][a-z])/g, function (v) {
        return v[1].toUpperCase();
      });
      delete object[key];
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && !blacklistAttributes.includes(key)) {
      value = camelize(value);
    }

    object[newKey] = value;
  }

  return object;
};

/**
 * @class
 * Connection information for an instance of Chain Core.
 */

var Connection = function () {
  /**
   * constructor - create a new Chain client object capable of interacting with
   * the specified Chain Core.
   *
   * @param {String} baseUrl Chain Core URL.
   * @param {String} token   Chain Core client token for API access.
   * @param {String} agent   https.Agent used to provide TLS config.
   * @returns {Client}
   */
  function Connection(baseUrl) {
    var token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var agent = arguments[2];

    _classCallCheck(this, Connection);

    this.baseUrl = baseUrl;
    this.token = token || '';
    this.agent = agent;
  }

  /**
   * Submit a request to the specified Chain Core.
   *
   * @param  {String} path
   * @param  {object} [body={}]
   * @returns {Promise}
   */


  _createClass(Connection, [{
    key: 'request',
    value: function request(path) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!body) {
        body = {};
      }

      // Convert camelcased request body field names to use snakecase for API
      // processing.
      var snakeBody = snakeize(body); // Ssssssssssss

      var req = {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'

        },
        body: JSON.stringify(snakeBody)
      };

      if (this.token) {
        req.headers['Authorization'] = 'Basic ' + btoa(this.token);
      }

      if (this.agent) {
        req.agent = this.agent;
      }

      return fetch(this.baseUrl + path, req).catch(function (err) {
        throw errors.create(errors.types.FETCH, 'Fetch error: ' + err.toString(), { sourceError: err });
      }).then(function (resp) {
        var requestId = resp.headers.get('Chain-Request-Id');
        if (!requestId) {
          throw errors.create(errors.types.NO_REQUEST_ID, 'Chain-Request-Id header is missing. There may be an issue with your proxy or network configuration.', { response: resp, status: resp.status });
        }

        if (resp.status == 204) {
          return { status: 204 };
        }

        return resp.json().catch(function () {
          throw errors.create(errors.types.JSON, 'Could not parse JSON response', { response: resp, status: resp.status });
        }).then(function (body) {
          if (resp.status / 100 == 2) {
            return body;
          }

          // Everything else is a status error.
          var errType = null;
          if (resp.status == 401) {
            errType = errors.types.UNAUTHORIZED;
          } else if (resp.status == 404) {
            errType = errors.types.NOT_FOUND;
          } else if (resp.status / 100 == 4) {
            errType = errors.types.BAD_REQUEST;
          } else {
            errType = errors.types.SERVER;
          }

          throw errors.create(errType, errors.formatErrMsg(body, requestId), {
            response: resp,
            status: resp.status,
            body: body,
            requestId: requestId
          });
        }).then(function (body) {
          // After processing the response, convert snakecased field names to
          // camelcase to match language conventions.
          return camelize(body);
        });
      });
    }
  }]);

  return Connection;
}();

Connection.snakeize = snakeize;
Connection.camelize = camelize;

module.exports = Connection;