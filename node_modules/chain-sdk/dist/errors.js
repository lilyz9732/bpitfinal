'use strict';

var lib = {
  create: function create(type, message) {
    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var err = void 0;
    if (props.body) {
      err = lib.newBatchError(props.body, props.requestId);
    } else {
      err = new Error(message);
    }

    err = Object.assign(err, props, {
      chainClientError: true,
      type: type
    });
    return err;
  },

  isChainError: function isChainError(err) {
    return err && !!err.chainClientError;
  },

  isBatchError: function isBatchError(v) {
    return v && v.code && !v.stack;
  },

  newBatchError: function newBatchError(body) {
    var requestId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var err = new Error(lib.formatErrMsg(body, requestId));
    err.code = body.code;
    err.chainMessage = body.message;
    err.detail = body.detail;
    err.requestId = requestId;
    err.resp = body.resp;
    return err;
  },

  // TODO: remove me in favor of ErrorBanner.jsx rendering
  formatErrMsg: function formatErrMsg(body, requestId) {
    var tokens = [];

    if (typeof body.code === 'string' && body.code.length > 0) {
      tokens.push('Code: ' + body.code);
    }

    tokens.push('Message: ' + body.message);

    if (typeof body.detail === 'string' && body.detail.length > 0) {
      tokens.push('Detail: ' + body.detail);
    }

    if (requestId) {
      tokens.push('Request-ID: ' + requestId);
    }

    return tokens.join(' ');
  },

  types: {
    FETCH: 'FETCH',
    CONNECTIVITY: 'CONNECTIVITY',
    JSON: 'JSON',
    UNAUTHORIZED: 'UNAUTHORIZED',
    NOT_FOUND: 'NOT_FOUND',
    BAD_REQUEST: 'BAD_REQUEST',
    SERVER_ERROR: 'SERVER_ERROR'
  }
};

module.exports = lib;