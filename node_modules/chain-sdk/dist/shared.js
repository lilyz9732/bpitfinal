'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var uuid = require('uuid');
var errors = require('./errors');
var Page = require('./page');

/**
 * @callback objectCallback
 * @param {error} error
 * @param {Object} object - Object response from API.
 */

/**
 * @callback batchCallback
 * @param {error} error
 * @param {BatchResponse} batchResponse - Newly created objects (and errors).
 */

/**
 * Called once for each item in the result set.
 *
 * @callback QueryProcessor
 * @param {Object} item - Item to process.
 * @param {function} next - Call to proceed to the next item for processing.
 * @param {function(err)} done - Call to terminate iteration through the result
 *                               set. Accepts an optional error argument which
 *                               will be passed to the promise rejection or
 *                               callback depending on async calling style.
 */

/**
 * @typedef {Object} Key
 * @global
 *
 * @property {String} rootXpub
 * @property {String} accountXpub
 * @property {String[]} accountDerivationPath
 */

/**
 * @class
 */

var BatchResponse =
/**
 * constructor
 *
 * @param  {Array<Object>} resp - List of items which are objects or errors.
 */
function BatchResponse(resp) {
  var _this = this;

  _classCallCheck(this, BatchResponse);

  /**
   * Items from the input array which were successfully processed. This value
   * is a sparsely populated array, maintaining the indexes of the items as
   * they were originally submitted.
   * @type {Array<Object>}
   */
  this.successes = [];

  /**
   * Items from the input array which resulted in an error. This value
   * is a sparsely populated array, maintaining the indexes of the items as
   * they were originally submitted.
   * @type {Array<Object>}
   */
  this.errors = [];

  resp.forEach(function (item, index) {
    if (item.code) {
      _this.errors[index] = item;
    } else {
      _this.successes[index] = item;
    }
  });

  /**
   * Original input array
   * @type {Array<Object>}
   */
  this.response = resp;
};

var tryCallback = function tryCallback(promise, cb) {
  if (typeof cb !== 'function') return promise;

  return promise.then(function (value) {
    setTimeout(function () {
      return cb(null, value);
    }, 0);
  }, function (error) {
    setTimeout(function () {
      return cb(error, null);
    }, 0);
  });
};

var batchRequest = function batchRequest(client, path, params, cb) {
  return tryCallback(client.request(path, params).then(function (resp) {
    return new BatchResponse(resp);
  }), cb);
};

module.exports = {
  batchRequest: batchRequest,

  singletonBatchRequest: function singletonBatchRequest(client, path) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var cb = arguments[3];

    return tryCallback(batchRequest(client, path, [params]).then(function (batch) {
      if (batch.errors[0]) {
        throw errors.newBatchError(batch.errors[0]);
      }
      return batch.successes[0];
    }), cb);
  },

  create: function create(client, path) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var object = Object.assign({ clientToken: uuid.v4() }, params);
    var body = object;
    if (!opts.skipArray) {
      body = [body];
    }

    return tryCallback(client.request(path, body).then(function (data) {
      if (errors.isBatchError(data[0])) throw errors.newBatchError(data[0]);

      if (Array.isArray(data)) return data[0];
      return data;
    }), opts.cb);
  },

  createBatch: function createBatch(client, path) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    params = params.map(function (item) {
      return Object.assign({ clientToken: uuid.v4() }, item);
    });

    return tryCallback(client.request(path, params).then(function (resp) {
      return new BatchResponse(resp);
    }), opts.cb);
  },

  query: function query(client, memberPath, path) {
    var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    return tryCallback(client.request(path, params).then(function (data) {
      return new Page(data, client, memberPath);
    }), opts.cb);
  },

  /*
   * NOTE: Requires query to be implemented on client for the specified member.
   */
  queryAll: function queryAll(client, memberPath, params) {
    var processor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
    var cb = arguments[4];

    var nextParams = params;

    var queryOwner = client;
    memberPath.split('.').forEach(function (member) {
      queryOwner = queryOwner[member];
    });

    var promise = new Promise(function (resolve, reject) {
      var done = function done(err) {
        if (cb) {
          cb(err);
          return;
        } else if (err) {
          reject(err);
        }

        resolve();
      };

      var nextPage = function nextPage() {
        queryOwner.query(nextParams).then(function (page) {
          var index = 0;
          var item = void 0;

          var next = function next() {
            if (index >= page.items.length) {
              if (page.lastPage) {
                done();
              } else {
                nextParams = page.next;
                nextPage();
              }
              return;
            }

            item = page.items[index];
            index++;

            // Pass the next item to the processor, as well as two loop
            // operations:
            //
            // - next(): Continue to next item
            // - done(err): Then terminate the loop by fulfilling the outer promise
            //
            // The process can also terminate the loop by returning a promise
            // that will reject.

            var res = processor(item, next, done);
            if (res && typeof res.catch === 'function') {
              res.catch(reject);
            }
          };

          next();
        }).catch(reject); // fail processor loop on query failure
      };

      nextPage();
    });

    return tryCallback(promise, cb);
  },

  tryCallback: tryCallback,
  BatchResponse: BatchResponse
};